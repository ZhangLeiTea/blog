# 源文件中的中文字符串

- `const char* name = "张磊";`
  - 字符串【张磊】存在放静态存储去
  - 编译器编译之后，内存中的数据因源文件的编码不同而不同

- ``` c++
  const int& age = 10;
  int age = 10;
  ```
  - 上面两个代码的区别：
  - 第一行的【10】会在静态存储区分配内存；age这个局部变量又会分配一次栈内存
  - 第二行是函数局部变量，只有一个栈内存。10的赋值，通过反汇编查看，是硬编码的

- C++11标准中增加了一些表示字符串常量的标识，如下有：
  - "张磊": 使用文件保存编码方式字符集
  - L"您好！"： wstring字符串常量，宽字符（串）由编译器翻译
  - R"(您 好 \n)": 原始字符串常量（字节数组），保留所有的字符
  - u8"您好！"： string字符串常量（字节数组），**使用UTF8进行编码保存**

- 宽字符（串）由编译器翻译，还是被硬编码进程序文件中。
  - 大写的L是告诉编译器：这是宽字符串。所以，这时候是需要编译器根据locale来进行翻译的
  - 这时候就要求源文件的编码与编译器的本地化策略集中代码翻译的策略一致，例如VC只能读取GB2312的源代码（这里还是例外，VC太自作聪明了 ，会将很多其他代码在编译时自动转换成GB2312），而gcc只能读取UTF-8的源代码（这里就有个尴尬，MinGW运行win32下，所以只有GB2312系统才认；而MinGW却用gcc编写，所以自己只认UTF-8，所以结果就是，MinGW的宽字符被废掉了）。

- C/C++的编译策略
  - ansi字符串
    - `const char* s = "中文abc";`
    - 忠实于源文件的编码为s赋值
    - 一般情况下，编译器会**忠实于源文件的编码为s赋值**，例外的情况比如VC会自作聪明的把大部分其他类型编码的字符串转换成GB2312（除了像UTF-8 without signature这样的幸存者）。
程序在执行的时候，s也就保持是这样的编码，不会再做其他的转换。
  - 宽字符串
    - `const wchar_t* ws = L"中文abc";`
    - 大写的L是告诉编译器：这是宽字符串。所以，这时候是需要编译器根据locale来进行翻译的
    - 比如，在Windows环境中，编译器的翻译策略是GB2312到UCS-2BE；Linux环境中的策略是UTF-8到UTF-32BE。
