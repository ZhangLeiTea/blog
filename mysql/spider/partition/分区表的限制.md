## 1. 为什么所有的唯一键都要包含分区键

&emsp;我们用一个反面的例子来说明这个问题，论证不是所有的唯一键都包含分区键，是会出问题的

&emsp;假设有如下分区表

``` sql
create table tbl_test (
    id int primary key,
    name varchar(30),
    id2 int,
    unique key(id2)
) engine = innodb;

-- tbl_test表的主键是id，唯一键是id2，并且按照id进行分区，即分区键是id（具体分区规则没有展示）
-- 现假设tbl_test对应2个分区：part1 = id < 10;  part2 = id < 20;
-- 现实中，我们是无法以id作为分区键的，这里仅是为了论证
```

&emsp;记下来往分区表tbl_test插入2条数据
`insert into tbl_test values (1, 'zhanglei', 1);`
`insert into tbl_test values (2, 'zhanglei2', 2);`

&emsp;执行update语句
`update tbl_test set id2=3;`
&emsp;这条update语句被mysql的partition插件依次分发到part1、part2两个分区去执行，注意分区表衍生出的2个分区衍生表（暂且这么命名吧）对mysql而言是独立的，这里独立的意思是mysql将每个分区表衍生表的处理，就将其当做是一个mysql真实的一个表来处理（拿唯一键来说，分区衍生表自己管理其唯一性）。
&emsp;mysql的分区插件呢，就像是一个协调器，按照某些规则将sql派发给各个分区衍生表（拿`update tbl_test set id2=3;`这个sql来说，分区插件会将其顺序派发给part1和part2，如果2个分区衍生表有一个执行失败了，那么分区插件判定这条语句失败。源码`ha_partition::direct_delete_rows@ha_parititon.cc`可以一窥一二；`ha_partition::exec_bulk_update`)
&emsp;`update tbl_test set id2=3;`这条语句会分别派发给2个分区衍生表，它们单独执行都没有问题，但对分区表整体而言，违反了唯一键的唯一性
&emsp;至此，推论出`所有的唯一键都要包含分区键`

**结论**

1. `所有的唯一键都要包含分区键` 是分区表的前置条件
2. 这个前置条件的目的，保证每个唯一键所确定的row都会落到同一个分区（假设有2个唯一键，那么分区键只能是2个唯一键的最左前缀）这保证了，只要其中一个唯一键确定的row是在分区1，那么该row对应的另一个唯一键也是在分区1
3. 目的：确保具有唯一属性的row落在相同的分区。不能产生脑裂的情况：具有唯一属性的行能落到不通的分区，如果是这样会违反整体的唯一性约束
