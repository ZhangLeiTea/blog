# 1. 

## 1. 目录结构简介

``` sql
|- libmysqlgcs  
    |- inlude/mysql/gcs        gcs的接口文件  
        |- gcs_control_interface.h  
    |- src  
        |- binds/xcom
            |- xcom
                |- xcom_base.h
                    |- ::xcom_input_signal()
                    |- xcom_try_pop_from_input_cb
                    |- local_server()                           ## 主循环
                    |- prepare_msg()
                    |- push_msg_2p                              ## proposer之后，直接是accept_op
                    |- propose_msg
                    |- send_to_acceptors
                    |- proposer_task
                    |- prop_majority()
                    |- ececutor_task
            |- gcs_xcom_control_interface.h
            |- gcs_xcom_interface.h                             ## xcom调用gcs的接口，xcom通过这些接口同gcs通信
                |- initialize_xcom()
                |- cb_xcom_input_try_pop()
            |- gcs_xcom_proxy.h
        |- interface
            |- xplatform
            |- 
        |- gcs_interface_factory.cc
|- src
    |-  observer_trans.cc
```

## plugin的入口

> mysql_declare_plugin(group_replication_plugin)@plugin.cc

``` c++
 mysql_declare_plugin(group_replication_plugin){
    MYSQL_GROUP_REPLICATION_PLUGIN,
    &group_replication_descriptor,
    "group_replication",
    PLUGIN_AUTHOR_ORACLE,
    "Group Replication (1.1.0)", /* Plugin name with full version*/
    PLUGIN_LICENSE_GPL,
    plugin_group_replication_init,            /* Plugin Init */
    plugin_group_replication_check_uninstall, /* Plugin Check uninstall */
    plugin_group_replication_deinit,          /* Plugin Deinit */
    0x0101,                                   /* Plugin Version: major.minor */
    group_replication_status_vars,            /* status variables */
    group_replication_system_vars,            /* system variables */
    nullptr,                                  /* config options */
    0,                                        /* flags */
} mysql_declare_plugin_end;
```

> stop group_replication; 指令
> > int plugin_group_replication_stop(char **error_message) 

## replication-channel

``` c++
enum enum_rpl_channel_type {
NO_CHANNEL_INFO = 0,       // No information exists about the channel  说明是primary-node，是正常mysq执行的事务（不是通过replica回放的事务）
RPL_STANDARD_CHANNEL = 1,  // It is a standard replication channel     
GR_APPLIER_CHANNEL = 2,    // It is a GR applier channel               此节点是secondary-node ，这个事务的执行是由sql线程执行的 
GR_RECOVERY_CHANNEL = 3    // It is a GR recovery channel              此节点是secondary-node，且正在恢复，还没有加入group。这个事务的发生，是由mgr的recovery阶段触发的事务
};
```

- GR_APPLIER_CHANNEL的事务是由 handle_slave_sql@rpl_slave函数调用的

---

``` c++
enum pax_op {
	client_msg = 0,                                 // mysql执行事务后产生trans-msg，经由xcom转发，这是paxos提案的前生，此时还不是paxos消息  （不确定视图变更、统计消息是不是也是这个）
	initial_op = 1,
	prepare_op = 2,                                 // paxos的提案的准备阶段
	ack_prepare_op = 3,
	ack_prepare_empty_op = 4,
	accept_op = 5,                                  // 提案的提出者，向决策者发起的消息，这是2pc的第二阶段
	ack_accept_op = 6,
	learn_op = 7,                                   // 学习消息，作用：采用一个提案。猜测：各个节点自己向自己发起
	recover_learn_op = 8,
	multi_prepare_op = 9,
	multi_ack_prepare_empty_op = 10,
	multi_accept_op = 11,
	multi_ack_accept_op = 12,
	multi_learn_op = 13,
	skip_op = 14,
	i_am_alive_op = 15,
	are_you_alive_op = 16,
	need_boot_op = 17,
	snapshot_op = 18,
	die_op = 19,
	read_op = 20,
	gcs_snapshot_op = 21,
	xcom_client_reply = 22,
	tiny_learn_op = 23,
	LAST_OP = 23 + 1
};

// pax_op::client_msg这个client-msg包含cargo_type的子类型



enum cargo_type {
	unified_boot_type = 0,
	xcom_boot_type = 1,
	xcom_set_group = 2,
	app_type = 4,
	exit_type = 7,
	reset_type = 8,
	begin_trans = 9,
	prepared_trans = 10,
	abort_trans = 11,
	view_msg = 12,
	remove_reset_type = 13,
	add_node_type = 14,
	remove_node_type = 15,
	enable_arbitrator = 16,
	disable_arbitrator = 17,
	force_config_type = 18,
	x_terminate_and_exit = 19,
	set_cache_limit = 20,
	get_event_horizon_type = 21,
	set_event_horizon_type = 22,
	get_synode_app_data_type = 23,
	convert_into_local_server_type = 24
};

```
---

## channel的理解

``` c++
/* A channel has a queue of data elements and a queue of waiting tasks */
struct channel {
  linkage data;             // 数据
  linkage queue;            // 任务。Put the task in a wait queue, then yield
};
```

``` c++
struct linkage {
  unsigned int type; /* Not strictly necessary, used for rudimentary run time
                        type check */
  linkage *suc;      /* Next in list */
  linkage *pred;     /* Previous in list */
};
```

### static inline linkage *link_out(linkage *self)

- 从双向链表中把self去除，并返回self
- 即 ptr0 -- self -- ptr1 变为 ptr0 -- ptr1, 然后返回self

### static inline void link_precede(linkage *self, linkage *ptr)

- 从self所在的双向链表中把self去除
- 将ptr的前驱设为self
- 即 ptr0 -- ptr -- ptr2  变为 ptr0 -- self -- ptr -- ptr2

### static inline void link_follow(linkage *self, linkage *ptr)

- 从self所在的双向链表中把self去除
- 将ptr的后继设为self
- 即 ptr0 -- ptr -- ptr2  变为 ptr0 -- ptr -- self -- ptr2
- ptr一般指链表的抽象，意思是把self放到链表中。follow的意思是：链表的下一个是self

---
## 2. 流控

1. 流控模块位于 pipeline_stats.h
  </br>
2. Pipeline_stats_member_message
   - 流水线成员的统计信息
   - 这个提供了encode()和decode(), 是用于xcom传输的message
3. Pipeline_stats_member_collector
   - 本地成员统计信息的流水线收集器
   - 用于处理local member stats

4. Pipeline_member_stats
   - 每个成员，计算后的统计信息
   - Flow_control_module::m_info 存储了这个类的实例







## 其他

1. Gtid_Executed_Message
   - 消息类型是：Plugin_gcs_message::CT_CERTIFICATION_MESSAGE
