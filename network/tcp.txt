【tcp】
Sequence Number         是包的序号，用来解决网络包乱序（reordering）问题。
Acknowledgement Number  就是ACK——用于确认收到，用来解决不丢包的问题。
Window                  又叫Advertised-Window，也就是著名的滑动窗口（Sliding Window），用于解决流控的。
TCP Flag                也就是包的类型，主要是用于操控TCP的状态机的。

【顺序号  确认号】
https://blog.csdn.net/cws1214/article/details/52430554

接收端给发送端的Ack确认只会确认最后一个连续的包
SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包，不然，发送端就以为之前的都收到了

比如，发送端发了1,2,3,4,5一共五份数据，接收端收到了1，2，于是回ack 3，然后收到了4（注意此时3没收到），此时的TCP会怎么办？
        # 超时重传机制
            一种是不回ack，死等3，当发送方发现收不到3的ack超时后，会重传3。一旦接收方收到3后，会ack 回 4——意味着3和4都收到了。
            但是，这种方式会有比较严重的问题，那就是因为要死等3，所以会导致4和5即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到Ack，所以，
            发送方可能会悲观地认为也丢了，所以有可能也会导致4和5的重传。
            对此有两种选择：
            一种是仅重传timeout的包。也就是第3份数据。
            另一种是重传timeout后所有的数据，也就是第3，4，5这三份数据(此时会接收到一个丢弃一个?直到超时)。
            这两种方式有好也有不好。第一种会节省带宽，但是慢(原因是直到超时，重传3，同时需要在服务端重组报文顺序?)，第二种会快一点，但是会浪费带宽，
            也可能会有无用功。但总体来说都不好。因为都在等timeout，timeout可能会很长（在下篇会说TCP是怎么动态地计算出timeout的）
        # 快速重传机制
            于是，TCP引入了一种叫Fast Retransmit 的算法，不以时间驱动，而以数据驱动重传。也就是说，如果，包没有连续到达，就ack最后那个可能被丢了的包，
            如果发送方连续收到3次相同的ack，就重传。Fast Retransmit的好处是不用等timeout了再重传。
            比如：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，
            但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6。示意图如下：
1. cwnd
    # congestion window   拥塞窗口
    # 拥塞控制

1.2 slding window 
    # advertised window 滑动窗口
    这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据
    我们都知道，TCP必需要解决的可靠传输以及包乱序（reordering）的问题，所以，TCP必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包

2. RTT
    # round trip time

3. RTO
    # Retransmission timeout
