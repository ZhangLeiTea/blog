【包】
1、包定义
	# 包是一种通过用“带点号的模块名”来构造 Python 模块命名空间的方法
	# 包是模块的集合，
	# 一个目录必须有 __init__.py 文件，才会被当做包
2、包使用
	# 包的用户可以从包中导入单个模块
		# import sound.effects.echo
	# 当使用 from package import item 时，item可以是包的子模块（或子包），也可以是包中定义的其他名称，如函数，类或变量
	当使用 import item.subitem.subsubitem 这样的语法时，除了最后一项之外的每一项都必须是一个包；
	最后一项可以是模块或包，但不能是前一项中定义的类或函数或变量
	
3、子模块、子包、包中定义的其他名称（函数、变量、类）

4、from package import * 
	# 如果一个包的 __init__.py 代码定义了一个名为 __all__ 的列表，它会被视为在遇到 from package import * 时应该导入的模块名列表

5、目录和包的区别
	# 如果是目录，你还想能导入的话，必须将目录加到sys.path中
	# 如果是包，包一定是在一个目录下，只要将包的父目录加到sys.path中，包的模块、子包、包的定义就都能找到

【模块】
1、可以作为module的文件类型有".py"、".pyo"、".pyc"、".pyd"、".so"、".dll"

2、模块是一个包含Python定义和语句的文件
	# 一个*.py文件就是一个模块，编写*.py文件也叫编写脚本
	# 模块可以包含【可执行的语句】以及【函数定义】
	# 出于效率的考虑，每个模块在每个解释器会话中只被导入一次。
	
2. import module
	# 解释器会加载module，将module中的符号--函数、变量、类型--用module封装，仅是将模块名加载到当前符号表中
	# 可以通过module.func()的形式调用module中的符号
	# 可执行的语句，在模块 第一次用import 语句导入时才执行
	
3、from fibo import fib, fib2
	# import 语句有一个变体，它可以把名字从一个被调模块内直接导入到现模块的符号表里
	
4、全局变量
	# 每个模块都有它自己的私有符号表  ？？？？？

【模块搜索路径】
	# 当前目录---sys.path中添加的目录（）----PYTHONPATH 中的目录-----标准库目录（Python安装目录下的Lib目录等）
		# 包含输入脚本的目录------标准库的路径 -----> sys.path 变量给出的目录列表里寻找名为 spam.py 的文件
		# sys.path 初始有这些目录地址
			# 包含输入脚本的目录（或者未指定文件时的当前目录）
			# PYTHONPATH （一个包含目录名称的列表，它和shell变量 PATH 有一样的语法）
			# 取决于安装的默认设置
		# 在初始化后，Python程序可以更改 sys.path。包含正在运行脚本的文件目录被放在搜索路径的开头处， 在标准库路径之前。
		这意味着将加载此目录里的脚本，而不是标准库中的同名模块。
	# 绝对路径和相对路径
		# 绝对路径	以模块搜索路径为基础
		# 相对路径	以当前目录为基础		以.或者..开头
	
6、 __pycache__ 目录

【import可以导入的东西】
1、可以导 模块、包、包的子包
2、只能是绝对导入。（搜索路基就是sys.path里的目录）
【from import】
1、可以是相对路径
	# 作为脚本运行时可能有些问题
2、可以是绝对路径

【标准模块】
1、dir()
	# 变量、函数、模块 
	# 不会列出内置变量、函数
2、builtins  内置模块   


【builtins】
1、globals
2、locals


【全局变量】
1. __name__
	# 代表py文件名
	# py文件作为脚本运行时，__name__ 就成了  '__main__'，表示程序入口


【符号的查找】
# 局部命名空间
	# 函数内的参数、函数内定义的变量
# 全局命名空间
	# 模块定义的变量、常亮、函数、导入的模块、导入的包、类
# 内置命名空间
	# __builtins__		定义了一些常用的函数


【变量作用域】
# 模块
# 类
# 函数
# if while for 没有作用域，定义的变量属于这些语句的外围

【装饰器】
# 不带参数的装饰器
	# 利用了函数闭包，在def _Decorator()返回包装函数 def _Wrapper(func)
	# 要点一：无参的装饰器返回包装函数
	# 要点二： 包装函数，接受一个参数参数就是被装饰的功能函数
	# 要点三： 额外增加的操作需要卸载包装函数中
	# 要点四： py解释器在加载py模块时，读到@装饰器时，会执行代码  func = Decorator(func)
			  这会导致1.Decorator()函数执行（副作用--注意奥写在_Wrapper()之外的代码会被执行奥）
			  		  2. func变量指向的新的函数指针--_Wrapper()函数
# 带参数的装饰器
	# 此装饰器需要返回一个新的装饰器
	# 相当于执行：func = Decorator(args)(func), 注意这里有两个函数的执行

# 多重装饰器
	# @log1
	  @log2
	  def func(): 
	  	pass
	# 装饰器从上往下装饰：func = log1(log2(func))