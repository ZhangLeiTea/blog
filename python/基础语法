1、类型
  1）值类型（不可变对象）：
      -- 数值、字符串、元组、bool
      -- 本身不允许修改
      -- 
  2）引用类型（可变对象）：
      -- list、set、dict、object
      
  3）总结：
    在py中变量永远都是指针，但不同的类型做出来区分值类型或者引用类型，这2者的本质是：是否可以修改自身（相当于C++中指针和const 指针的区别）


## 2、变量的理解
  1）需要确认变量指向的类型
  2）=赋值运算符。a = 'zhanglei'。只要是赋值运算：申请新的内存空间，变量名指向这个新的内存空间
  
# 2.1 赋值运算符
  1）只要是赋值运算：第一步-申请新的内存空间，第二部-变量名指向这个新的内存空间
  
3、参数传递
  1）py中参数的传递都是指针（引用），区别是这个对象是可变对象还是不可变对象
      def test_immutable_for_simpledata(args):
        print('============')
        print(2, id(args))
        args = args + 10
        print(3, args)
        print(4, id(args))
        print('============')


      if __name__ == '__main__':
        cur = 5000
        print(1, id(cur))
        test_immutable_for_simpledata(cur)
        print(5, cur)
        print(6, id(cur))
  2）原则
    -- Python对不可变类型传参是使用的引用传参
    -- 基本类型的不可变对象，对它进行运算操作其实就是创建新的对象，然后将原先的变量名绑定到新的对象上
    
4、名字空间
  1）py中万物皆对象，对象是通过key-values的形式索引的。
  2）变量的作用域：
      -- 全局变量：以module为界，可以将module看做是C++的名字空间
      -- 局部变量：只有函数级没有块级作用域
  3）import test_a
      -- 上面语句的作用：将'test_a'这个key放到了这个模块的__dict__里（可以用globals()获取）其value呢就是test_a这个模块（可以看到它的类型是
         module）
  4) from test_a import name
      -- 该模块的globals里添加了'name'这个key，可以说加了'name'这个变量
      -- 这个name变量能不能改，就看是不是可变的
      -- 对这个变量的赋值，不论是否可变，都是重新分配内存，让后变量指向新的内存


===============================================================
【包】
1、包定义
	# 包是一种通过用“带点号的模块名”来构造 Python 模块命名空间的方法
	# 包是模块的集合，
	# 一个目录必须有 __init__.py 文件，才会被当做包
2、包使用
	# 包的用户可以从包中导入单个模块
		# import sound.effects.echo
	# 当使用 from package import item 时，item可以是包的子模块（或子包），也可以是包中定义的其他名称，如函数，类或变量
	当使用 import item.subitem.subsubitem 这样的语法时，除了最后一项之外的每一项都必须是一个包；
	最后一项可以是模块或包，但不能是前一项中定义的类或函数或变量
	
3、子模块、子包、包中定义的其他名称（函数、变量、类）

4、from package import * 
	# 如果一个包的 __init__.py 代码定义了一个名为 __all__ 的列表，它会被视为在遇到 from package import * 时应该导入的模块名列表

5、目录和包的区别
	# 如果是目录，你还想能导入的话，必须将目录加到sys.path中
	# 如果是包，包一定是在一个目录下，只要将包的父目录加到sys.path中，包的模块、子包、包的定义就都能找到

【模块】
1、可以作为module的文件类型有".py"、".pyo"、".pyc"、".pyd"、".so"、".dll"

2、模块是一个包含Python定义和语句的文件
	# 一个*.py文件就是一个模块，编写*.py文件也叫编写脚本
	# 模块可以包含【可执行的语句】以及【函数定义】
	# 出于效率的考虑，每个模块在每个解释器会话中只被导入一次。
	
2. import module
	# 解释器会加载module，将module中的符号--函数、变量、类型--用module封装，仅是将模块名加载到当前符号表中
	# 可以通过module.func()的形式调用module中的符号
	# 可执行的语句，在模块 第一次用import 语句导入时才执行
	
3、from fibo import fib, fib2
	# import 语句有一个变体，它可以把名字从一个被调模块内直接导入到现模块的符号表里
	
4、全局变量
	# 每个模块都有它自己的私有符号表  ？？？？？

【模块搜索路径】
	# 当前目录---sys.path中添加的目录（）----PYTHONPATH 中的目录-----标准库目录（Python安装目录下的Lib目录等）
		# 包含输入脚本的目录------标准库的路径 -----> sys.path 变量给出的目录列表里寻找名为 spam.py 的文件
		# sys.path 初始有这些目录地址
			# 包含输入脚本的目录（或者未指定文件时的当前目录）
			# PYTHONPATH （一个包含目录名称的列表，它和shell变量 PATH 有一样的语法）
			# 取决于安装的默认设置
		# 在初始化后，Python程序可以更改 sys.path。包含正在运行脚本的文件目录被放在搜索路径的开头处， 在标准库路径之前。
		这意味着将加载此目录里的脚本，而不是标准库中的同名模块。
	# 绝对路径和相对路径
		# 绝对路径	以模块搜索路径为基础
		# 相对路径	以当前目录为基础		以.或者..开头
	
6、 __pycache__ 目录

【import可以导入的东西】
1、可以导 模块、包、包的子包
2、只能是绝对导入。（搜索路基就是sys.path里的目录）
【from import】
1、可以是相对路径
	# 作为脚本运行时可能有些问题
2、可以是绝对路径

【标准模块】
1、dir()
	# 变量、函数、模块 
	# 不会列出内置变量、函数
2、builtins  内置模块   


【builtins】
1、globals
2、locals


【全局变量】
1. __name__
	# 代表py文件名
	# py文件作为脚本运行时，__name__ 就成了  '__main__'，表示程序入口


【符号的查找】
# 局部命名空间
	# 函数内的参数、函数内定义的变量
# 全局命名空间
	# 模块定义的变量、常亮、函数、导入的模块、导入的包、类
# 内置命名空间
	# __builtins__		定义了一些常用的函数


【变量作用域】
# 模块
# 类
# 函数
# if while for 没有作用域，定义的变量属于这些语句的外围

【装饰器】
# 不带参数的装饰器
	# 利用了函数闭包，在 [def _Decorator()] 返回包装函数 def _Wrapper(func)
	# 要点一： 无参的装饰器返回包装函数
	# 要点二： 包装函数，接受一个参数参数就是被装饰的功能函数
	# 要点三： 额外增加的操作需要封装在包装函数中。处于装饰函数与包装函数之间的代码，也是会执行的，这时副作用
	# 要点四： py解释器在加载py模块时，读到@装饰器时，会执行代码  func = Decorator(func)
			  这会导致	1.Decorator()函数执行（副作用--注意奥写在_Wrapper()之外的代码会被执行奥）
			  	   2. func变量指向的新的函数指针--_Wrapper()函数
# 带参数的装饰器
	# 此装饰器需要返回一个新的装饰器
	# 相当于执行：func = Decorator(args)(func), 注意这里有两个函数的执行

# 多重装饰器
	# @log1
	  @log2
	  def func(): 
	  	pass
	# 装饰器从上往下装饰：func = log1(log2(func))
  
  
  ===================================================================================
  
  有意思的语法
  1. func = True and (lambda x: x+1) or (lambda x: x+2)
  	- func的赋值，取决于True or False
